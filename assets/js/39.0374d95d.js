(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{569:function(e,v,t){"use strict";t.r(v);var _=t(4),s=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"浏览器中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中"}},[e._v("#")]),e._v(" 浏览器中")]),e._v(" "),t("p",[e._v("js 是单线程，首先将 script 全局代码压入执行栈（宏任务）然后代码从上往下依次执行，遇到同步放到主线程中执行，形成执行然后出栈，遇到微任务或宏任务分别放入对应的异步队列中等待执行，当执行栈为空时，检查微任务队列是否有任务，有则依次推入执行栈中执行，否则宏任务队列是否有任务，有则推入执行栈执行出栈后，再检查微任务队列如此循环")]),e._v(" "),t("p",[e._v("宏任务 -> 同步任务 -> 微任务 -> 宏任务")]),e._v(" "),t("p",[e._v("在浏览器器中所有的任务都会被放到"),t("code",[e._v("调用栈")]),e._v("中等待主线程执行\n同步任务在 "),t("code",[e._v("调用栈")]),e._v(" 中按照顺序依次等待主线程执行，而异步任务则会在异步任务有结果之后，将"),t("code",[e._v("回调函数")]),e._v("放入消息队列中，当"),t("code",[e._v("主线程任务执行完毕调用栈")]),e._v(" 为空时，将其取到 "),t("code",[e._v("调用栈")]),e._v(" 中等待主线程执行")]),e._v(" "),t("p",[e._v("异步任务又可分为微任务和宏任务，微任务。所以"),t("code",[e._v("消息队列")]),e._v("又可细分为 微任务 和 宏任务 队列，当主线程任务执行完之后，会先查看微任务队列是否有任务，如果没有再查看宏任务队列如果有任务会将任务推到 "),t("code",[e._v("调用栈")]),e._v(" 中执行\n")]),e._v(" "),t("h4",{attrs:{id:"微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[e._v("#")]),e._v(" 微任务")]),e._v(" "),t("p",[t("code",[e._v("Promise")]),e._v(" "),t("code",[e._v("MutationObserver")]),e._v(" 和 node.js 的 "),t("code",[e._v("Process.nextTick")])]),e._v(" "),t("h4",{attrs:{id:"宏任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[e._v("#")]),e._v(" 宏任务")]),e._v(" "),t("p",[t("code",[e._v("setTimeout")]),e._v(" "),t("code",[e._v("setInterval")]),e._v(" "),t("code",[e._v("setImmediate")]),e._v(" "),t("code",[e._v("script")])]),e._v(" "),t("h3",{attrs:{id:"node-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js"}},[e._v("#")]),e._v(" Node.js")]),e._v(" "),t("p",[e._v("在 Node.js 中 Event loop 有 6 个阶段，其中比较重要的有"),t("code",[e._v("timers")]),e._v(" "),t("code",[e._v("poll")]),e._v(" "),t("code",[e._v("check")])]),e._v(" "),t("blockquote",[t("p",[e._v("node11 之前中事件循环和浏览器中最大的区别在于执行微任务和宏任务的时机不同。执行栈清空后执行微任务再执行宏任务，不会想浏览器中一样每次清空执行栈都会检查微任务队列，只有在当前阶段执行完毕（所有宏任务执行完）再检查微任务队列")])])])}),[],!1,null,null,null);v.default=s.exports}}]);