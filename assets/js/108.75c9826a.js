(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{637:function(e,t,r){"use strict";r.r(t);var a=r(4),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("使用 Vue2 很久了，但是知道怎么用一直没关心过内部实现。最近有时间打算深入了解下 Vue2 的响应式原理")]),e._v(" "),r("h2",{attrs:{id:"基本结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本结构"}},[e._v("#")]),e._v(" 基本结构")]),e._v(" "),r("p",[e._v("vue2 的数据响应式是通过 defineProperty API 和结合"),r("RouterLink",{attrs:{to:"/blogs/设计模式/发布订阅与观察者模式.html"}},[e._v("观察者模式")]),e._v("实现的")],1),e._v(" "),r("ol",[r("li",[r("p",[e._v("vue 实例初始化时会通过，通过 "),r("code",[e._v("Object.defineProperty")]),e._v(" 把 data 中的成员注入到实例中， 方便使用时直接通过 this.属性名 使用")])]),e._v(" "),r("li",[r("p",[e._v("创建 Observer 将 data 中的属性转换为 getter 和 setter, 并在属性 get 的时候调用 dep 的 addSub 方法添加观察者（收集依赖），在 set 的时候调用 dep 的 notify 方法通知观察者（通知依赖）")])]),e._v(" "),r("li",[r("p",[e._v("创建 Compiler 解析指令和差值表达式并将数据替换成 data 中相应的数据，并创建 "),r("code",[e._v("Watcher")]),e._v(" （观察者） 指定更新视图的回调函数 (update 方法）")])]),e._v(" "),r("li",[r("p",[e._v("当数据更新时会触发数据的 set 方法，在 set 方法中会通过 "),r("code",[e._v("Dep.notify")]),e._v(" 通知依赖，执行 Watcher 的 update 方法更新视图。")])])]),e._v(" "),r("p",[r("img",{attrs:{src:"/images/WX20210114-224329@2x.png",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"简易版的-vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简易版的-vue"}},[e._v("#")]),e._v(" 简易版的 Vue")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://gitee.com/tq_ian/min-vue",target:"_blank",rel:"noopener noreferrer"}},[e._v("min-vue"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);